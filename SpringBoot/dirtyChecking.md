Dirty-Checking and @DynamicUpdate
================
회사에서 코틀린 스프링부트를 프로젝트를 진행하던 도중 엔티티에 @DynamicUpdate가 붙어 있는 것을 보고  
@DynamicUpdate가 무엇이고 왜 @DynamicUpdate를 쓸까 생각해봤다. @DynamicUpdate를 하지 않아도 엔티티는 잘 동작하기 때문이다.  
@DynamicUpdate를 잘 이해하기 위해서는 더티 체킹(dirty checking)에 대해서도 이해하고 있어야 하기 때문에 더티 체킹부터 설명하겠다.  

### Dirty-Checking 
더티 체킹은 이동욱님의 스프링부트 책을 정독했다면 알고 있을 개념이다.  
한 줄로 요약하면  
### repository.save()같은 메소드로 변경 사항을 저장하지 않아도 엔티티의 변경만으로 변경 사항이 저장되는 것을 말한다.  

이번 글은 이동욱님의 블로그에 정리가 너무 잘되어 있어서 인용해왔다... 꼭 숙지해야 할 개념이다.

### 이하 블로그글 인용  

  출처 : https://jojoldu.tistory.com/415  

"repository의 save 메소드로 변경 사항을 저장하지 않았음에도 update 쿼리가 실행되었습니다.  
이유는 Dirty Checking 덕분인데요.  

여기에서 Dirty란 상태의 변화가 생긴 정도로 이해하시면 됩니다.  
즉, Dirty Checking이란 상태 변경 검사 입니다.  

JPA에서는 트랜잭션이 끝나는 시점에 변화가 있는 모든 엔티티 객체를 데이터베이스에 자동으로 반영해줍니다.  

이때 변화가 있다의 기준은 최초 조회 상태입니다.  

JPA에서는 엔티티를 조회하면 해당 엔티티의 조회 상태 그대로 스냅샷을 만들어놓습니다.  
그리고 트랜잭션이 끝나는 시점에는 이 스냅샷과 비교해서 다른점이 있다면 Update Query를 데이터베이스로 전달합니다."  

### @DynamicUpdate

위에서는 dirty-checking에 대해서 알아보았다.  
transactional한 상태에서는 엔티티의 변경만으로도 db에 데이터를 변경할 수 있는 것이었다.  
그런데 기본적으로 더티 체킹으로 생성되는 업데이트 혹은 인서트 쿼리는 모든 필드를 업데이트한다.

전체 필드를 업데이트하면 아래와 같은 장점이 있기 때문이다.

1. 생성되는 쿼리가 같아 부트 실행시점에 미리 만들어서 재사용가능  
2. 데이터베이스 입장에서 쿼리 재사용이 가능 >> 동일한 쿼리를 받으면 이전에 파싱된 쿼리를 재사용  

하지만 전체 필드를 업데이트하지 않고 싶을 수도 있는데 그 때 사용하는 것이  
@Dynamicupdate이다. 이 어노테이션은 엔티티 위에 써주면 변경된 필드만 sql에 반영하게 해준다.  

다만 이 어노테이션은 테이블에 컬럼이 20~30개 이상일 때 전체 업데이트가 힘들 수 있으므로 사용하는 것인데  
트래픽이나 복잡도가 높은 배민에서도 컬럼 최대개수가 15개라고 한 것을 보고 많은 생각이 들었다.
회사에서는 컬럼이 50개가 넘어가는 테이블도 있기 때문이다. 






