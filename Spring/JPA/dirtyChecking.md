Dirty-Checking and @DynamicUpdate
================
회사에서 코틀린 스프링부트를 프로젝트를 진행하던 도중 엔티티에 @DynamicUpdate가 붙어 있는 것을 보고  
@DynamicUpdate가 무엇이고 왜 @DynamicUpdate를 쓸까 생각해봤다. @DynamicUpdate를 하지 않아도 엔티티는 잘 동작하기 때문이다.  
@DynamicUpdate를 잘 이해하기 위해서는 더티 체킹(dirty checking)에 대해서도 이해하고 있어야 하기 때문에 더티 체킹부터 설명하겠다.  

### Dirty-Checking 
더티 체킹은 이동욱님의 스프링부트 책을 정독했다면 알고 있을 개념이다.  
한 줄로 요약하면  
### repository.save()같은 메소드로 변경 사항을 저장하지 않아도 엔티티의 변경만으로 변경 사항이 저장되는 것을 말한다.  

이번 글은 이동욱님의 블로그의 글을 인용해왔다... 꼭 숙지해야 할 개념이다.

### 이하 블로그글 인용  

  출처 : https://jojoldu.tistory.com/415  

"repository의 save 메소드로 변경 사항을 저장하지 않았음에도 update 쿼리가 실행되었습니다.  
이유는 Dirty Checking 덕분인데요.  

여기에서 Dirty란 상태의 변화가 생긴 정도로 이해하시면 됩니다.  
즉, Dirty Checking이란 상태 변경 검사 입니다.  

JPA에서는 트랜잭션이 끝나는 시점에 변화가 있는 모든 엔티티 객체를 데이터베이스에 자동으로 반영해줍니다.  

이때 변화가 있다의 기준은 최초 조회 상태입니다.  

JPA에서는 엔티티를 조회하면 해당 엔티티의 조회 상태 그대로 스냅샷을 만들어놓습니다.  
그리고 트랜잭션이 끝나는 시점에는 이 스냅샷과 비교해서 다른점이 있다면 Update Query를 데이터베이스로 전달합니다."  

### 정리

다시 정리하면 jpa가 엔티티를 영속성 콘텍스트에 보관할 때 최초 상태인 '스냅샷'을 보관하는데  
플러시 시점에 보관했던 스냅샷과 변경된 엔티티를 비교해 어떤 것이 변경되었는지 찾아 데이터베이스로 보내는 것이다.  

- 영속성 콘텍스트는 간단히 말해서 엔티티 매니저가 db와 소통하기 전, 애플리케이션 레벨에서 엔티티를 영구 저장하는 환경이다.  
  영속성 콘텍스트는 1차 캐시, 동일성 보장, 트랜잭션을 위한 쓰기 지연, 스냅샷 변경 감지 같은 특징이자 장점을 가지고 있다.
  
- 플러시는 말 그대로 전부 내려보내는 것으로, 영속성 컨텍스트가 관리하던 '쓰기 지연 sql 저장소'의 쿼리들을 db로 보내는 단계이다.  
  


### @DynamicUpdate

위에서는 dirty-checking에 대해서 알아보았다.  
transactional한 상태에서는 엔티티의 변경만으로도 db에 데이터를 변경할 수 있는 것이었다.  
그런데 기본적으로 더티 체킹으로 생성되는 업데이트 혹은 인서트 쿼리는 모든 필드를 업데이트한다.

전체 필드를 업데이트하면 아래와 같은 장점이 있기 때문이다.

1. 생성되는 쿼리가 같아 부트 실행시점에 미리 만들어서 재사용가능  
2. 데이터베이스 입장에서 쿼리 재사용이 가능 >> 동일한 쿼리를 받으면 이전에 파싱된 쿼리를 재사용  

하지만 전체 필드를 업데이트하지 않고 싶을 수도 있는데 그 때 사용하는 것이  
@Dynamicupdate이다. 이 어노테이션은 엔티티 위에 써주면 변경된 필드만 sql에 반영하게 해준다.  

다만 이 어노테이션은 테이블에 컬럼이 20~30개 이상일 때 전체 필드의 업데이트가 느릴 수 있으므로 사용하는 것이고  
테이블 필드가 적다면 굳이 사용할 필요가 없다.  
그렇게 @DynamicUpdate를 사용한 이유가 테이블의 컬럼이 많기 때문에 사용했던 것을 알 수 있었다.  

하지만 여기서 더 고민해 볼 문제가 있다.

이동욱님의 글을 읽어보면서 트래픽이나 서비스 복잡도가 높은 배민에서도 컬럼 최대개수가 15개라고 한 것을 보고 많은 생각이 들었다.  
회사에서는 컬럼이 50개가 넘어가는 테이블도 있기 때문이다.  
그리고 또한 테이블의 컬럼이 많은 것은 정규화를 잘 하지 못한 테이블이라고 했다.  
물론 컬럼이 많다고 해서 좋지 않은 구조라고 단정 지을 수는 없지만, 배민이 웬만한 기업보다 트래픽과 서비스 복잡도가 높을 것 아닌가?  

맹목적으로 대기업의 기술이나 스택을 따라가는 것은 지양해야 하지만 왜 그 기술을 택했는가에 대해 알아보는 것은  
언제나 필요하다. (물론 많은 기업에서 동일한 스택을 사용한다면 그 스택은 사실상 검증된 것이긴 하다.. 에를 들면 next.js나 스프링 부트..!)

나는 당연히 테이블의 복잡도는 서비스의 복잡도로부터 나오는 것이라고 생각했고, 핀테크에서도 이 정도  
많은 컬럼을 사용하니까 다른 곳도 이 정도로 사용하겠다고 은연중에 그렇게 생각하고 있었는데 내 오산이었다.   

그래서 다음 db포스팅은 테이블 설계와 프로그래밍 간의 관계에 대해서 글을 써볼 계획이다.







